---
title: Android 组件化的个人理解 
tags: 新建,模板,小书匠
grammar_cjkRuby: true
---
# 结构图
![PandaMvp 组件化结构图](./images/1554614230256.png)
其中路由数据组件为上层业务组件必须要依赖的库，独立功能组件和公共 UI 组件可以根据需求选择是否依赖。公共 UI 组件为应用整体 UI 风格上的公共配置和封装，一般业务组件也都会依赖。基础SDK 为最底层的 SDK 库，所有的业务组件都基于它。如果路由组件中用不到基础 SDK 中的功能，路由组件不需要依赖它。顶层的业务 APP 一般按功能模块进行划分譬如：`邮件 App`、`IM App`、`视频 App`
# 为什么要做组件化
一、做组件化主要是随着软件的版本迭代，暴露出一个巨大的问题。同一个 module 下，各种数据跳转之间高度的耦合了，虽然开发要求要注意代码的耦合度，但团队中每个人的经验水平和编码风格都不一样，对这个耦合程度的理解和标准也不一样，随着时间推移模块间的代码会越写相互依赖程度越大。毕竟有时候明明能直接拿过来用，就不会太多的去考虑设计模式。做组件化将相对独立的模块独立出去，达到硬性代码隔离，强制降低模块耦合度的目的。
二、项目随着开发需求的不断迭代会变得越来越庞大，开发过程中项目整编是个很费时的事，组件化之后可以灵活配置选择需要的组件编译，缩短时间
三、多个项目中有的组件是可以共用的，像我经历过的两个项目的网盘模块和邮件模块。未采用组件化方案，移代码移资源太费时费力了。采用组件化方案，直接将 module 导入新的项目，增加对应的路由和 路由Service 方法就能用（前提是项目都采用组件化方案）
# 组件化过程中的几个问题
## 多个组件 module 怎样共用 Application
这个问题不是组件化的问题，只要项目多 module 开发就有这个问题。这里我们参考了 Glide 的自定义 Module 方案。通过 `Manifest `文件增加 meta 配置，在基础 Application 初始化时新建一个代理类，并绑定生命周期方法，在代理类中扫描   `Manifest `文件拿到每个 module 下的生命周期实现类，将这些实现类的生命周期方法注入到代理类的生命周期方法中。达到每个 module 都能在 Application 的生命周期方法中执行想要执行的代码。


## Activity 及 Fragment 生命周期
## 组件间的通信
组件中的通信这里采用了 ARouter
### 注意事项
1、ARouter 分组不能重复
2、使用 AutoWired 绑定服务时一定要在对应位置调用 `ARouter.getInstance().inject(this)` 去发现服务，否则会找不到服务
## ORM 数据库，数据的共享
# 其他思考

